/**
 * @param {number[][]} intervals
 * @param {number[]} queries
 * @return {number[]}
 */
var minInterval = function(intervals, queries) {
  intervals.sort((a, b) => a[0] - b[0]);
  const sortedQueries = queries.map((q, i) => [q, i]).sort((a, b) => a[0] - b[0]);
  const ans = Array(queries.length).fill(-1);

  class Heap {
    constructor(compare) {
      this.data = [];
      this.compare = compare;
    }
    size() { return this.data.length; }
    top() { return this.data[0]; }
    push(x) {
      this.data.push(x);
      this._up(this.data.length - 1);
    }
    pop() {
      if (!this.size()) return null;
      const top = this.data[0];
      const end = this.data.pop();
      if (this.size()) {
        this.data[0] = end;
        this._down(0);
      }
      return top;
    }
    _up(i) {
      const a = this.data;
      while (i > 0) {
        const p = (i - 1) >> 1;
        if (this.compare(a[p], a[i]) <= 0) break;
        [a[p], a[i]] = [a[i], a[p]];
        i = p;
      }
    }
    _down(i) {
      const a = this.data;
      const n = this.size();
      while (true) {
        let smallest = i;
        const l = 2 * i + 1, r = 2 * i + 2;
        if (l < n && this.compare(a[l], a[smallest]) < 0) smallest = l;
        if (r < n && this.compare(a[r], a[smallest]) < 0) smallest = r;
        if (smallest === i) break;
        [a[i], a[smallest]] = [a[smallest], a[i]];
        i = smallest;
      }
    }
  }

  const heap = new Heap((a, b) => a[0] - b[0]);
  let idx = 0;

  for (const [q, qi] of sortedQueries) {
    while (idx < intervals.length && intervals[idx][0] <= q) {
      const [l, r] = intervals[idx++];
      heap.push([r - l + 1, r]);
    }

    while (heap.size() && heap.top()[1] < q) heap.pop();

    if (heap.size()) ans[qi] = heap.top()[0];
  }

  return ans;
};
