/**
 * @param {number[]} nums
 * @param {number[]} target
 * @return {number}
 */
function gcd(a, b) {
  a = Math.abs(a);
  b = Math.abs(b);
  while (b !== 0) {
    [a, b] = [b, a % b];
  }
  return a;
}

function _lcm(a, b) {
  if (a === 0 || b === 0) return 0;
  return Math.abs(a / gcd(a, b) * b);
}

var minimumIncrements = function(nums, target) {
    const n = nums.length
    const m = target.length
    let memo = Array(1<<m).fill(0).map(()=>Array(n).fill(-1))
    let helper = (p , mask) =>{
        if(mask === ((1 << m) - 1)) return 0
        if(p === n) return Infinity
        let res = Infinity
        if(memo[mask][p] !== -1) return memo[mask][p]
        for(let i = 0 ; i < (1 << m) ; i++){
            //check if one of the candiates is already matched
            if(mask & i) continue
            // ts holds my candiates
            let ts = []
            for(let j = 0 ; j < m ; j++){
                if((i >> j) & 1){
                    ts.push(target[j])
                }
            }
            //getting the lcm of my candidates that is >= to nums[p]
            let lcm = ts.length ? 1 : nums[p]
            for(let j = 0 ; j < ts.length ; j++){
                lcm = _lcm(lcm , ts[j])
            }
            if(lcm !== nums[p] && lcm < nums[p]){
                const k = Math.ceil(nums[p] / lcm);
                if (k < 1) k = 1;
                lcm = lcm * k
            }
            // how many ops do i need to make nums[p] === lcm
            res = Math.min(res , lcm - nums[p] + helper(p+1 , mask | i))
        }
        memo[mask][p] = res
        return res
    }
    return helper(0,0)
};
