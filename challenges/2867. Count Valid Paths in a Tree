class Solution {
    genPrimes(n) {
        const prime = new Array(n + 1).fill(false);
        if (n > 1) prime.fill(true, 2); // Initializing all numbers >= 2 as prime.
        for (let i = 2; i <= n; ++i) {
            if (prime[i]) {
                for (let j = i + i; j <= n; j += i) {
                    prime[j] = false; // Marking multiples of prime numbers as not prime.
                }
            }
        }
        return prime;
    }

    countPaths(n, edges) {
        const isPrime = this.genPrimes(n); // Generate a list of prime numbers up to 'n'.
        const E = new Array(n).fill().map(() => []); // Creating an adjacency list for the graph.

        // Populate the adjacency list based on given edges.
        for (const [u, v] of edges) {
            const uIdx = u - 1;
            const vIdx = v - 1;
            E[uIdx].push(vIdx);
            E[vIdx].push(uIdx);
        }

        let ans = 0; // Initialize the answer to zero.

        // Depth-first search (DFS) function to traverse the tree and count paths.
        const dfs = (x, p) => {
            const prime = isPrime[x + 1]; // Check if the node number (1-based) is prime.
            const cur = [0, 0]; // Initialize an array to store counts based on prime status.
            cur[prime] += 1; // Update the count for prime or non-prime node.

            for (const y of E[x]) {
                if (y === p) continue; // Skip the parent node.
                const v = dfs(y, x); // Recursively traverse the tree.

                // Update the answer by counting paths based on prime and non-prime nodes.
                const nonPrime = prime === 0 ? 1 : 0;
                ans += v[0] * cur[nonPrime];
                ans += v[1] * cur[prime];

                cur[prime] += v[0]; // Update counts for the current node.
                cur[nonPrime] += v[1]; // If non-prime, update the count for non-prime nodes.
            }
            return cur; // Return the count array for the current node.
        };

        dfs(0, -1); // Start DFS from the root node (node 0) with parent -1.

        return ans; // Return the final count of paths.
    }
}
