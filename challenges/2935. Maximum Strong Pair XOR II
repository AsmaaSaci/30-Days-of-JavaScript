var maximumStrongPairXor = function(nums) {
  nums.sort((a, b) => a - b);
  let n = nums.length, trie = new BitwiseTrie(), maxXor = 0;
  for (let i = 0, j = 0; i < n; i++) {
    if (i > 0) trie.removeNum(nums[i - 1]);
    while (j < n && nums[j] - nums[i] <= nums[i]) {
      trie.addNum(nums[j]);
      j++;
    }
    maxXor = Math.max(maxXor, trie.maxXor(nums[i]));
  } 
  return maxXor;
};

class TrieNode {
  constructor() {
    this.children = Array(2);
    this.num = null;
    this.count = 0;
  }
}

class BitwiseTrie {
  constructor() {
    this.root = new TrieNode();
  }
  addNum(num) {
    let node = this.root;
    for (let i = 20; i >= 0; i--) {
      let bit = (num >> i) & 1; 
      node = node.children;
      if (!node[bit]) node[bit] = new TrieNode();
      node = node[bit];
      node.count++;
    }
    node.num = num;
  }
  removeNum(num) {
    let node = this.root;
    for (let i = 20; i >= 0; i--) {
      let bit = (num >> i) & 1;
      node = node.children;
      node[bit].count--;
      if (node[bit].count <= 0) {
        node[bit] = null;
        break;
      }
      else node = node[bit];
    }
  }
  maxXor(num) {
    let node = this.root;
    for (let i = 20; i >= 0; i--) {
      let bit = (num >> i) & 1, opposite = bit ^ 1;
      node = node.children;
      if (node[opposite]) node = node[opposite];
      else node = node[bit];
    }
    return num ^ node.num;
  }
}
