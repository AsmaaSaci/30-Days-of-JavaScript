/**
 * @template TItemKey
 */
class DisjointSets {
  /**
   * @template TItemKey
   * @typedef {{ rank: number, parent: TItemKey, key: TItemKey }} SetNode<TItemKey>
   */

  constructor() {
    /**
     * @private
     * @type {Map<TItemKey, SetNode<TItemKey>>}
     */
    this._nodesMapper = new Map();

    /**
     * @private
     * @type {number}
     */
    this._numberOfSets = 0;
  }

  getKeys() {
    return Array.from(this._nodesMapper.keys());
  }

  getNumberOfSets() {
    return this._numberOfSets;
  }

  /**
   * @param  {TItemKey} key
   * @returns {boolean}
   */
  has(key) {
    return this._nodesMapper.has(key);
  }

  /**
   * @param  {...TItemKey} keys
   */
  add(...keys) {
    for (let key of keys) {
      if (this._nodesMapper.has(key)) continue;
      this._nodesMapper.set(key, { rank: 1, parent: key, key });
      this._numberOfSets++;
    }
  }

  /**
   * @param {TItemKey} key
   * @returns {TItemKey}
   */
  getRoot(key) {
    let node = this._requireNode(key);
    /** @type {SetNode<TItemKey>[]} */
    let path = [];
    while (node.parent !== node.key) {
      path.push(node);
      node = this._requireNode(node.parent);
    }
    path.forEach((pathNode) => (pathNode.parent = node.key));
    return node.key;
  }

  /**
   * @param  {...TItemKey} keys
   */
  union(...keys) {
    const first = keys[0];
    if (!first == null) return;

    for (let i = 1; i < keys.length; i++) {
      this._union2Sets(first, keys[i]);
    }
  }

  /**
   * @private
   * @param {TItemKey} key1
   * @param {TItemKey} key2
   */
  _union2Sets(key1, key2) {
    const root1 = this._requireNode(this.getRoot(key1));
    const root2 = this._requireNode(this.getRoot(key2));

    if (root1.key === root2.key) return;

    if (root1.rank < root2.rank) {
      root2.rank += root1.rank;
      root1.parent = root2.key;
    } else {
      root1.rank += root2.rank;
      root2.parent = root1.parent;
    }
    this._numberOfSets--;
  }

  /**
   * @private
   * @param {TItemKey} key
   */
  _requireNode(key) {
    const node = this._nodesMapper.get(key);
    if (!node) throw new Error(`Key "${key}" is missing from the Disjoint Set.`);
    return node;
  }

  /**
   * @param  {...TItemKey} keys
   */
  isSameSet(...keys) {
    if (keys.length <= 1) return true;
    const roots = keys.map(k => this.getRoot(k));
    return roots.every(r => r === roots[0]);
  }
}

/**
 * @param {number} row
 * @param {number} col
 * @param {number[][]} cells
 * @return {number}
 */
var latestDayToCross = function(row, col, cells) {
  const ds = new DisjointSets() 
  ds.add("L", "R");

  function toDsKey(r, c) {
    if (r === 0 || r > row) return null;
    if (c === 0) return "L";
    if (c > col) return "R";
    return `${r}_${c}`;
  }

  function connect(cell) {
    const curKey = toDsKey(cell[0], cell[1]);
    ds.add(curKey);
    for (let i = -1; i <= 1; i++) {
      for (let j = -1; j <= 1; j++) {
        if (i === 0 && j === 0) continue;

        const toKey = toDsKey(cell[0] + i, cell[1] + j);
        if (toKey !== null && ds.has(toKey)) ds.union(curKey, toKey);
      }
    }
  }

  for (let i = 0; i < cells.length; i++) {
    connect(cells[i]);
    if (ds.isSameSet("L", "R")) return i;
  }
};
