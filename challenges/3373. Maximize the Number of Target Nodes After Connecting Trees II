class Solution {
  constructor() {
    this.evenA = 0;
    this.oddA = 0;
    this.evenB = 0;
    this.oddB = 0;
  }

  buildList(edges) {
    const n = edges.length + 1;
    const adj = Array.from({ length: n }, () => []);
    for (const [u, v] of edges) {
      adj[u].push(v);
      adj[v].push(u);
    }
    return adj;
  }

  bfsColor(adj, color, isA) {
    const queue = [0];
    color[0] = 0;

    while (queue.length > 0) {
      const u = queue.shift();
      if (color[u] === 0) {
        if (isA) this.evenA++;
        else this.evenB++;
      } else {
        if (isA) this.oddA++;
        else this.oddB++;
      }

      for (const v of adj[u]) {
        if (color[v] === -1) {
          color[v] = color[u] ^ 1;
          queue.push(v);
        }
      }
    }
  }

  maxTargetNodes(edges1, edges2) {
    const adjA = this.buildList(edges1);
    const adjB = this.buildList(edges2);
    const n = adjA.length;
    const m = adjB.length;
    const colorA = Array(n).fill(-1);
    const colorB = Array(m).fill(-1);

    this.evenA = this.oddA = this.evenB = this.oddB = 0;
    this.bfsColor(adjA, colorA, true);
    this.bfsColor(adjB, colorB, false);

    const maxiB = Math.max(this.evenB, this.oddB);
    return Array.from({ length: n }, (_, i) =>
      (colorA[i] === 0 ? this.evenA : this.oddA) + maxiB
    );
  }
}
