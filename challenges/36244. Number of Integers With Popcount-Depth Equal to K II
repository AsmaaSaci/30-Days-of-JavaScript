var popcountDepth = function(nums, queries) {
    const n = nums.length
    function popcount(x){
        let c=0
        while(x>0){
            c += x%2
            x = Math.floor(x/2)
        }
        return c
    }
    function depthOf(x){
        if(x===1) return 0
        let d=0
        while(x!==1){
            x = popcount(x)
            d++
        }
        return d
    }
    class Fenwick{
        constructor(n){ this.n=n; this.bit=new Array(n+1).fill(0) }
        add(i,v){
            for(; i<=this.n; i += i & -i) this.bit[i] += v
        }
        sum(i){
            let s=0
            for(; i>0; i -= i & -i) s += this.bit[i]
            return s
        }
        range(l,r){ if(r<l) return 0; return this.sum(r)-this.sum(l-1) }
    }
    const MAXD = 6
    const f = Array.from({length:MAXD}, ()=> new Fenwick(n))
    const depths = new Array(n)
    for(let i=0;i<n;i++){
        let d = depthOf(nums[i])
        if(d>=MAXD) d = MAXD-1
        depths[i]=d
        f[d].add(i+1,1)
    }
    const ans=[]
    for(const q of queries){
        if(q[0]===1){
            const l=q[1], r=q[2], k=q[3]
            if(k<0||k>=MAXD) { ans.push(0); continue }
            ans.push(f[k].range(l+1,r+1))
        } else {
            const idx=q[1], val=q[2]
            let old = depths[idx]
            let nd = depthOf(val)
            if(nd>=MAXD) nd = MAXD-1
            if(old===nd){ nums[idx]=val; continue }
            f[old].add(idx+1,-1)
            f[nd].add(idx+1,1)
            depths[idx]=nd
            nums[idx]=val
        }
    }
    return ans
}
