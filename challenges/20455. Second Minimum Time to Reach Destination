var secondMinimum = function(n, edges, time, change) {
    const g = Array.from({length: n+1}, ()=>[]);
    for(const [u,v] of edges){
        g[u].push(v);
        g[v].push(u);
    }

    class MinHeap {
        constructor(){ this.a = []; }
        size(){ return this.a.length; }
        push(x){
            this.a.push(x);
            let i = this.a.length-1;
            while(i>0){
                let p = (i-1)>>1;
                if(this.a[p][0] <= this.a[i][0]) break;
                [this.a[p], this.a[i]] = [this.a[i], this.a[p]];
                i = p;
            }
        }
        pop(){
            const a = this.a;
            const top = a[0];
            const last = a.pop();
            if(a.length){
                a[0] = last;
                let i = 0;
                while(true){
                    let l = i*2+1, r = l+1, m = i;
                    if(l < a.length && a[l][0] < a[m][0]) m = l;
                    if(r < a.length && a[r][0] < a[m][0]) m = r;
                    if(m === i) break;
                    [a[m], a[i]] = [a[i], a[m]];
                    i = m;
                }
            }
            return top;
        }
    }

    const dist = Array.from({length: n+1}, ()=>[]);
    const pq = new MinHeap();
    pq.push([0,1]);

    while(pq.size()){
        const [t,u] = pq.pop();

        // skip if this time is not eligible (already have two better times)
        if(dist[u].length === 0){
            dist[u].push(t);
        } else if(dist[u].length === 1){
            if(t === dist[u][0]) continue;
            if(t > dist[u][0]) dist[u].push(t);
            else continue;
        } else {
            // already have two times
            if(t === dist[u][0] || t === dist[u][1]) continue;
            if(t > dist[u][1]) continue;
            // t < dist[u][1] but dist[u] already has two (this case unlikely due to min-heap), ignore
            continue;
        }

        if(u === n && dist[u].length === 2) return dist[u][1];

        for(const v of g[u]){
            let nt = t;
            // if signal is red when trying to leave u, wait until next green
            if(Math.floor(nt / change) % 2 === 1){
                nt += (change - (nt % change));
            }
            nt += time;
            // push candidate if v has less than 2 recorded times
            if(dist[v].length < 2) pq.push([nt, v]);
        }
    }

    return -1;
};
