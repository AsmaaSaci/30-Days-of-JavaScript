const counter = (a_or_s) => { let m = new Map(); for (const x of a_or_s) m.set(x, m.get(x) + 1 || 1); return m; };
const removeOneMap = (m, x) => { let occ = m.get(x); occ > 1 ? m.set(x, occ - 1) : m.delete(x); };
const deepCopyMap = (m) => new Map(m);

const recoverArray = (a) => {
    a.sort((x, y) => x - y)
    let n = a.length, res = [], cnt = counter(a);
    for (let i = 1; i < n; i++) {
        let k = a[i] - a[0], m = deepCopyMap(cnt);
        res = [];
        if (ok(k, a, m, res)) return res;
    }
    return [];
};

// greedy: check each possible k with lower[i]
const ok = (k, a, m, res) => {
    if (k == 0 || k & 1) return false;
    for (const low of a) {
        if (m.has(low)) {
            let mid = low + (k >> 1), high = low + k; // assume the condition
            res.push(mid);
            removeOneMap(m, low);
            if (m.has(high)) {
                removeOneMap(m, high);
            } else { // high not exist in original array
                return false;
            }
        }
    }
    return true;
};
