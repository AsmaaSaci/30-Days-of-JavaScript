function maxWalls(robots, distance, walls) {
    let A = robots.map((r, i) => [r, distance[i]]).sort((a, b) => a[0] - b[0]);
    const N = A.length;
    walls.sort((a, b) => a - b);

    function count(L, R) {
        if (L > R) return 0;

        function bisectLeft(arr, target) {
            let lo = 0, hi = arr.length;
            while (lo < hi) {
                let mid = Math.floor((lo + hi) / 2);
                if (arr[mid] < target) lo = mid + 1;
                else hi = mid;
            }

            return lo;
        }

        function bisectRight(arr, target) {
            let lo = 0, hi = arr.length;
            while (lo < hi) {
                let mid = Math.floor((lo + hi) / 2);
                if (arr[mid] <= target) lo = mid + 1;
                else hi = mid;
            }

            return lo;
        }

        return bisectRight(walls, R) - bisectLeft(walls, L);
    }

    const inf = 1e18;
    let used = count(A[0][0] - A[0][1], A[0][0] - 1);
    let avail = 0;
    A.push([inf, 0]);

    for (let i = 0; i < N; i++) {
        let [l, dl] = A[i];
        let [r, dr] = A[i + 1];
        let l1 = l + 1, r1 = Math.min(l + dl, r - 1);
        let l2 = Math.max(r - dr, l + 1), r2 = r - 1;
        let left = count(l1, r1);
        let right = count(l2, r2);
        let both = left + right - count(Math.max(l1, l2), Math.min(r1, r2));
        let navail = Math.max(avail + left, used);
        let nused = Math.max(avail + both, used + right);
        avail = navail;
        used = nused;
    }

    let robotPositions = new Set(A.map(x => x[0]));
    for (let x of robotPositions) used += count(x, x);
    return used;
}
