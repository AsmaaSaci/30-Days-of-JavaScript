/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {string} label
 * @return {number}
 */
var maxLen = function(n, edges, label) {
    // Initialize dp as a 3D array filled with -1
    const dp = Array.from({ length: n + 1 }, () =>
        Array.from({ length: n + 1 }, () =>
            Array((1 << (n + 1))).fill(-1)
        )
    );
    
    // Build graph as an adjacency list
    const graph = {};
    for (let i = 0; i < n; i++) {
        graph[i] = new Set();
    }

    // Build connectivity matrix
    const connect = Array.from({ length: n + 1 }, () =>
        Array(n + 1).fill(0)
    );
    
    for (const [u, v] of edges) {
        graph[u].add(v);
        graph[v].add(u);
        connect[u][v] = 1;
        connect[v][u] = 1;
    }

    // Recursive function
    function recur(i, j, vi) {
        if (i === j) {
            return 1;
        }
        if (dp[i][j][vi] !== -1) {
            return dp[i][j][vi];
        }
        let ans = 0;
        for (const k of graph[i]) {
            if ((vi & (1 << k)) !== 0) continue;
            for (const w of graph[j]) {
                if ((vi & (1 << w)) !== 0) continue;
                if (label[k] !== label[w]) continue;
                const e = recur(k, w, vi | (1 << k) | (1 << w));
                if (e > 0) {
                    ans = Math.max(ans, e);
                }
            }
        }
        if (ans === 0 && connect[i][j] === 0) {
            dp[i][j][vi] = 0;
            return 0;
        }
        dp[i][j][vi] = ans + 2;
        return dp[i][j][vi];
    }

    let ans = 1;
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            if (label[i] === label[j]) {
                ans = Math.max(ans, recur(i, j, (1 << i) | (1 << j)));
            }
        }
    }

    return ans;
};
