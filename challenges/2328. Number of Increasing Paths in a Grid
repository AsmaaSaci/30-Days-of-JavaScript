/**
 * @param {number[][]} grid
 * @return {number}
 */
var countPaths = function (grid) {
    const MOD = 1e9 + 7; // Define the modulus
    const m = grid.length;
    const n = grid[0].length;

    const memo = Array.from({ length: m }, () => Array(n).fill(0));
    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

    const dfs = (i, j) => {
        if (memo[i][j] > 0) return memo[i][j]; // If already computed, return the result

        let count = 1; // Start with the cell itself

        for (const [dx, dy] of directions) {
            const newRow = i + dx;
            const newCol = j + dy;

            // Check bounds and ensure the neighbor has a greater value
            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol] > grid[i][j]) {
                count = (count + dfs(newRow, newCol)) % MOD; // Accumulate paths and apply modulo
            }
        }
        memo[i][j] = count; // Store result in memoization table
        return count;
    };

    let paths = 0;

    // Compute paths starting from every cell
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            paths = (paths + dfs(i, j)) % MOD; // Add paths and apply modulo
        }
    }

    return paths;
};
