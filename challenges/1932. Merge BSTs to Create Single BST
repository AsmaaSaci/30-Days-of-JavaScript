var canMerge = function(trees) {
  let leaves = new Map(), roots = new Set(), nodesCnt = 0, n = trees.length;

  // map roots to matching leaves
  for (let tree of trees) {
    roots.add(tree.val);
    nodesCnt++;
    if (tree.left) {
      leaves.set(tree.left.val, tree); // save the parent/root so that we can replace it easily
      nodesCnt++;
    }
    if (tree.right) {
      leaves.set(tree.right.val, tree); // save the parent/root so that we can replace it easily
      nodesCnt++;
    }
  }
  nodesCnt = nodesCnt - (n - 1); // there are exactly n - 1 overlapping nodes counted
  
  // get the finalRoot
  let finalRoot = null;
  for (let tree of trees) {
    if (!leaves.has(tree.val)) {
      finalRoot = tree;
    }
  }
  
  for (let tree of trees) {
    if (tree !== finalRoot && leaves.has(tree.val)) {
      let leafParent = leaves.get(tree.val);
      if (leafParent.left && leafParent.left.val === tree.val) {
        leafParent.left = tree;
      } else {
        leafParent.right = tree;
      }
      roots.delete(tree.val); // after merging, delete the root. There should be exactly 1 root left at the end.
    }
  }
  // must be one root left, and node count must equal the total nodes
  return roots.size === 1 && countNodes(finalRoot) === nodesCnt ? finalRoot : null;
};

function countNodes(root, min = -Infinity, max = Infinity) {
  if (!root) return 0;
  if (root.val <= min || root.val >= max) return 0;
  return 1 + countNodes(root.left, min, root.val) + countNodes(root.right, root.val, max);
}
