/**
 * @param {number[][]} edges
 * @param {number[]} cost
 * @return {number[]}
 */
var placedCoins = function (edges, cost) {
    const adjList = [];

    // create adjacency list
    for (let [n, nn] of edges) {
        while (adjList.length <= n || adjList.length <= nn) {
            adjList.push([]);
        }
        adjList[n].push(nn);
        adjList[nn].push(n);
    }

    const result = Array(adjList.length);

    const dfs = (node, parent) => {
        // if there is no nodes in adjacency list other than parent node
        if (adjList[node].length === 1 && node !== 0) {
            result[node] = 1;
            if (cost[node] < 0) {
                return [0, [], [cost[node]]];
            }
            return [0, [cost[node]], []];
        }

        // 3 max positive costs
        const costs = cost[node] <= 0 ? [] : [cost[node]];
        // 2 min negative costs
        const negativeCosts = cost[node] < 0 ? [cost[node]] : [];

        // subtree of the current node is number of nodes childrens + node itself
        let currentSubtrees = node === 0 ? adjList[node].length + 1 : adjList[node].length;

        // iterate through nodes
        for (const nextNode of adjList[node]) {
            if (nextNode === parent) continue;
            // return from child node what is the count of the subtree
            // list of 3 highest costs and list of 2 smallest negative costs
            const [childSubtree, positive, negative] = dfs(nextNode, node);

            // take the max of the currentSubtree and subtrees from child nodes
            // + 1 -> because we need to calculate in the current node
            currentSubtrees = Math.max(currentSubtrees, childSubtree + 1);

            // merge result arrays with current arrays
            // sort arrays - positive costs DESC, and negative costs ASC
            // remove more than 3 elements from positive costs
            // remove more than 2 elements from negative costs
            negativeCosts.push(...negative);
            negativeCosts.sort((a, b) => a - b);
            costs.push(...positive);
            costs.sort((a, b) => b - a);
            while (costs.length > 3) costs.pop();
            while (negativeCosts.length > 2) negativeCosts.pop();
        }

        // if subtree is less than 3 then result will be 1
        if (currentSubtrees < 3) {
            result[node] = 1;
        } else {
            let product = 0;
            let negativeProduct = 0;
            // if we have 3 positive costs then multiply them
            if (costs.length === 3) product = costs[0] * costs[1] * costs[2];
            // if we have 2 negative, multiply them 
            // we need to check if we have at least one positive
            // if there is no positive then we will need to take 3 negatives with result < 0
            if (negativeCosts.length === 2 && costs.length > 0) {
                negativeProduct = (costs[0] ?? 1) * negativeCosts[0] * negativeCosts[1];
            }

            result[node] = Math.max(product, negativeProduct);
        }

        return [currentSubtrees, costs, negativeCosts];
    }

    dfs(0);
    return result;
};
