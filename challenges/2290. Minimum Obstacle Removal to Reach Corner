/**
 * @param {number[][]} grid
 * @return {number}
 */
var minimumObstacles = function(grid) {
    const m = grid.length;
    const n = grid[0].length;
    const moves = [[1,0],[-1,0],[0,1],[0,-1]]

    function bfs() {
        const deque = new Deque();
        const dist = new Array(m).fill().map(() => {
            return new Array(n).fill(-1);
        });

        let node = [0, 0, 0];
        deque.pushBack(node);

        dist[0][0] = 0;

        while (deque.size() > 0) {
            const [effort, i, j] = deque.popFront();

            for (const [di, dj] of moves) {
                const [ni, nj] = [i + di, j + dj];
                if (ni < 0 || ni >= m || nj < 0 || nj >= n) continue;
                if (dist[ni][nj] != -1) continue;

                const newEffort = effort + grid[ni][nj];
                const newNode = [newEffort, ni, nj];
                dist[ni][nj] = newEffort;
                if (newEffort > effort) {
                    deque.pushBack(newNode);
                }
                else {
                    deque.pushFront(newNode);
                }
            }
        }

        return dist[m - 1][n - 1];
    }

    return bfs();
};
