/**
 * @param {string} low
 * @param {string} high
 * @return {number}
 */
var countSteppingNumbers = function(low, high) {
    const modMe = 1e9 + 7
    const dgt2nexts = [
        [1],
        [0, 2],
        [1, 3],
        [2, 4],
        [3, 5],
        [4, 6],
        [5, 7],
        [6, 8],
        [7, 9],
        [8],
    ]

    // for a given number represented as String str, 
    // get a function solver such that 
    // solver() === (how many stepping numbers <= str)
    function getSolver(str) {
        const len = str.length
        if (len === 1) {
            const dgt = Number(str)
            return function() {
                return dgt
            }
        }

        const digits = [...str].map(Number)
        const firstDgt = digits[0]
        const lenM = len - 1
        // fromI, status, prev
        // statuses: 
        // 0 => prefix is smaller than str
        // 1 => prefix is the same as str
        // 2 => prefix is larger than str
        const memo = new Array(len)
        for (const i of memo.keys()) {
            const row = memo[i] = new Array(3)
            for (const j of row.keys())
                row[j] = []
        }
        
        function dp(fromI, status, prev) {
            if (fromI === len)  return 1

            const ext = memo[fromI][status][prev]
            if (ext !== undefined)  return ext

            let result = 1
            const nexts = dgt2nexts[prev]
            const fromIP = 1 + fromI
            for (const next of nexts) {
                if (status === 0) {
                    result = (result + dp(fromIP, 0, next)) % modMe
                } else if (status === 1) {
                    const hereDgt = digits[fromI]
                    if (next < hereDgt) {
                        result = (result + dp(fromIP, 0, next)) % modMe
                    } else if (next === hereDgt) {
                        result = (result + dp(fromIP, 1, next)) % modMe
                    } else {
                        if (fromI !== lenM) {
                            result = (result + dp(fromIP, 2, next)) % modMe
                        }
                    }
                } else {
                    if (fromI !== lenM) {
                        result = (result + dp(fromIP, 2, next)) % modMe
                    }
                }
            }

            return memo[fromI][status][prev] = result
        }

        // return the solver function
        return function() {
            let result = 0
            // handle the first digit
            // exclude 0 because no leading zero is allowed
            for (let dgt = 1; dgt < 10; dgt++) {
                let outcome
                if (dgt < firstDgt) {
                    outcome = dp(1, 0, dgt)
                } else if (dgt === firstDgt) {
                    outcome = dp(1, 1, dgt)
                } else {
                    outcome = dp(1, 2, dgt)
                }
                result = (result + outcome) % modMe
            }

            return result
        }
    }


    // get the difference set
    const b = high
    const solverB = getSolver(b), outcomeB = solverB()

    const A = BigInt(low) - 1n, a = A.toString()
    const solverA = getSolver(a), outcomeA = solverA()

    const result = (modMe + outcomeB - outcomeA) % modMe
    return result
};
